##### 2020-10-25 일요일



# 02_큰수의 법칙 [92p]

## 문제

- 동빈이의 '큰 수의 법칙'은 다양한 수로 이루어진 배열이 있을때, 주어진 수들을 M번 더하여 가장 큰수를 만드는 법칙이다.

- 단, 배열의 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것이 이 법칙의 특징이다.

- 예를들어, 순서대로 2, 4, 5, 4, 6으로 이루어진 배열이 있을때, M이 8이고 K가 3이라고 가정하자.

- 이 경우 특정한 인덱스 수가 연속해서 세 번까지만 더해질 수 있음으로 큰 수의 법칙에 따른 결과는6 + 6 + 6 + 5 + 6 + 6 + 6 + 5인 46이 된다.

- 단, 서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 것으로 간주한다.

- 예를들어, 순서대로 3, 4, 3, 4, 3으로 이루어진 배열이 있을때, M이 7이고 K가 2라고 가정하자.

- 이 경우 두 번째 원소에 해당하는 4와 네 번째 원소에 해당하는 4를 번갈아 두번씩 더하는 것이 가능하다.

- 결과적으로 4 + 4 + 4 + 4 + 4 + 4 + 4인 28이 된다

- 배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때, 동빈이의 큰 수 법칙에 따른 결과를 출력하시오

- ( 2 <= N <= 1,000 ) // (1 <= N M= 10,000) // (1 <= K <= 10,000)



## 나의 풀이

그리디 알고리즘 문제라는 것을 안 상태에서 풀었다. 만약 그리지 알고리즘을 적용해서 푸는 문제인지 몰랐다면 풀지 못했을것이다.

```python
import sys

N, M, K = map(int, sys.stdin.readline().split())
input_list = list(map(int, sys.stdin.readline().split()))

input_list.sort()

big1 = input_list[N-1]
big2 = input_list[N-2]

one_cycle = 3*big1 + big2

mok = M // 4
na = M % 4

sum = one_cycle * mok + big1 * na
print(sum)
```



- 결론적으로 가장 큰 수와 두번째로 큰수를 활용하여 푸는 문제였다.
-  `(가장큰수) + (가장큰수) + (가장큰수) + (두번째로 큰수) `꼴로 더해지는 형태이기 때문에, 쉽게 풀 수있었던 것 같다.
- 책의 풀이와 나의 풀이가 비슷한 원리를 적용하여 풀었기 때문에 따로 정리하지는 않겠다.